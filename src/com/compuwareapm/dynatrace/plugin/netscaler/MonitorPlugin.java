
 /**
  * This template file was generated by dynaTrace client.
  * The dynaTrace community portal can be found here: http://community.compuwareapm.com/
  * For information how to publish a plugin please visit http://community.compuwareapm.com/plugins/contribute/
  **/ 

package com.compuwareapm.dynatrace.plugin.netscaler;

import com.dynatrace.diagnostics.pdk.*;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.net.URI;
import java.util.Collection;
import java.util.logging.Logger;

import org.apache.http.HttpEntity;
import org.apache.http.StatusLine;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;
import org.json.JSONArray;
import org.json.JSONObject;

public class MonitorPlugin implements Monitor {

	private static final Logger log = Logger.getLogger(MonitorPlugin.class.getName());

	private String username = "";
	private String password = "";
	private String port = "";
	private String uri = "";
	private String service = "";

	/**
	 * Initializes the Plugin. This method is called in the following cases:
	 * <ul>
	 * <li>before <tt>execute</tt> is called the first time for this
	 * scheduled Plugin</li>
	 * <li>before the next <tt>execute</tt> if <tt>teardown</tt> was called
	 * after the last execution</li>
	 * </ul>
	 * <p>
	 * If the returned status is <tt>null</tt> or the status code is a
	 * non-success code then {@link Plugin#teardown() teardown()} will be called
	 * next.
	 * <p>
	 * Resources like sockets or files can be opened in this method.
	 * @param env
	 *            the configured <tt>MonitorEnvironment</tt> for this Plugin;
	 *            contains subscribed measures, but <b>measurements will be
	 *            discarded</b>
	 * @see Plugin#teardown()
	 * @return a <tt>Status</tt> object that describes the result of the
	 *         method call
	 */
	@Override
	public Status setup(MonitorEnvironment env) throws Exception {
		username = env.getConfigString("username");
		password = env.getConfigPassword("password");
		port = env.getConfigString("port");
		uri = env.getConfigString("uri");
		service = env.getConfigString("service");

		return new Status(Status.StatusCode.Success);
	}

	/**
	 * Executes the Monitor Plugin to retrieve subscribed measures and store
	 * measurements.
	 *
	 * <p>
	 * This method is called at the scheduled intervals. If the Plugin execution
	 * takes longer than the schedule interval, subsequent calls to
	 * {@link #execute(MonitorEnvironment)} will be skipped until this method
	 * returns. After the execution duration exceeds the schedule timeout,
	 * {@link TaskEnvironment#isStopped()} will return <tt>true</tt>. In this
	 * case execution should be stopped as soon as possible. If the Plugin
	 * ignores {@link TaskEnvironment#isStopped()} or fails to stop execution in
	 * a reasonable timeframe, the execution thread will be stopped ungracefully
	 * which might lead to resource leaks!
	 *
	 * @param env
	 *            a <tt>MonitorEnvironment</tt> object that contains the
	 *            Plugin configuration and subscribed measures. These
	*            <tt>MonitorMeasure</tt>s can be used to store measurements.
	 * @return a <tt>Status</tt> object that describes the result of the
	 *         method call
	 */
	@Override
	public Status execute(MonitorEnvironment env) throws Exception {
		try {
			String host = env.getHost().getAddress();
			//String fulluri = "http://"+host+":"+port+uri;
			String fulluri = new URI(
				    "http", 
				    host, 
				    uri+"/"+service,
				    null).toASCIIString();
			
			log.fine("----------------------------------------");
			log.fine("Host: "+host);
			log.fine("Port: "+port);
			log.fine("URI: "+uri);
			log.fine("Username: "+username);
			log.fine("Service: "+service);
			
	        /*CredentialsProvider credsProvider = new BasicCredentialsProvider();
	        credsProvider.setCredentials(
	                new AuthScope("localhost", 8020),
	                new UsernamePasswordCredentials("admin", "admin"));
	        CloseableHttpClient httpclient = HttpClients.custom()
	                .setDefaultCredentialsProvider(credsProvider)
	                .build();*/
			
			double avgsvrttfb = 0;
			double responsesrate = 0;
			double state = 0;
			double curclntconnections = 0;
			double cursrvrconnections = 0;
			boolean foundService = false;
					
			CloseableHttpClient httpclient = HttpClients.createDefault();
			try {
				HttpGet httpget = new HttpGet(fulluri);
				httpget.addHeader("X-NITRO-USER", username);
				httpget.addHeader("X-NITRO-PASS", password);
				//httpget.addHeader("Content-Type", "application/vnd.com.citrix.netscaler.lbvserver+json");
				log.fine("Request: " + httpget);
				CloseableHttpResponse response = httpclient.execute(httpget);
				try {
					log.fine("Response: " + response.getStatusLine().toString());
					HttpEntity entity = response.getEntity();

					StatusLine sl = response.getStatusLine();
					if (sl.getStatusCode()==200) {
						String content = EntityUtils.toString(entity);
						log.fine("Content: " + content);
						JSONObject jContent = new JSONObject(content);
						int errorCode = jContent.getInt("errorcode");
						if (errorCode == 0) {
							JSONArray jServiceArray = jContent.getJSONArray("service");
						    JSONObject jService = jServiceArray.getJSONObject(0);
							foundService = true;
							log.fine("Service: "+jService.getString("name"));
							avgsvrttfb = jService.getDouble("avgsvrttfb");
							log.fine("Average TTFB: "+avgsvrttfb);
							responsesrate = jService.getDouble("responsesrate");
							log.fine("Responses Rate: "+responsesrate);
							String statestring = jService.getString("state");
							if (statestring!=null && statestring.equalsIgnoreCase("up"))
								state = 1;
							else
								state = 0;
							log.fine("State: "+statestring);
							curclntconnections = jService.getDouble("curclntconnections");
							log.fine("Current client connections: "+curclntconnections);
							cursrvrconnections = jService.getDouble("cursrvrconnections");
							log.fine("Current server connections: "+cursrvrconnections);
						}
						else {
							log.severe("JSON request came back with error code "+errorCode);
							log.severe("Error message: "+jContent.getString("message"));
							return new Status(Status.StatusCode.ErrorTargetService);
						}
					}
					else {
						log.severe("HTTP request returned with status code "+sl.getStatusCode());
						return new Status(Status.StatusCode.ErrorTargetService);
					}
						
				} finally {
					response.close();
				}
			} finally {
				httpclient.close();
			}
			
			if (foundService) {
				Collection<MonitorMeasure> monitorMeasures = env.getMonitorMeasures();
				for (MonitorMeasure subscribedMonitorMeasure : monitorMeasures) {
					if (subscribedMonitorMeasure.getMetricName().equals("Average TTFB")) {
						MonitorMeasure dynamicMeasure = env.createDynamicMeasure(subscribedMonitorMeasure, "Service Name", service);
						dynamicMeasure.setValue(avgsvrttfb);
					} else if (subscribedMonitorMeasure.getMetricName().equals("Response Rates")) {
						MonitorMeasure dynamicMeasure = env.createDynamicMeasure(subscribedMonitorMeasure, "Service Name", service);
						dynamicMeasure.setValue(responsesrate);
					} else if (subscribedMonitorMeasure.getMetricName().equals("State")) {
						MonitorMeasure dynamicMeasure = env.createDynamicMeasure(subscribedMonitorMeasure, "Service Name", service);
						dynamicMeasure.setValue(state);
					} else if (subscribedMonitorMeasure.getMetricName().equals("Current Client Connections")) {
						MonitorMeasure dynamicMeasure = env.createDynamicMeasure(subscribedMonitorMeasure, "Service Name", service);
						dynamicMeasure.setValue(curclntconnections);
					} else if (subscribedMonitorMeasure.getMetricName().equals("Current Server Connections")) {
						MonitorMeasure dynamicMeasure = env.createDynamicMeasure(subscribedMonitorMeasure, "Service Name", service);
						dynamicMeasure.setValue(cursrvrconnections);
					}
				}
			}
		}
		catch (Exception e) {
			StringWriter sw = new StringWriter();
			PrintWriter pw = new PrintWriter(sw);
			e.printStackTrace(pw);
			log.severe(sw.toString()); 
		}
		
		return new Status(Status.StatusCode.Success);
	}

	/**
	 * Shuts the Plugin down and frees resources. This method is called in the
	 * following cases:
	 * <ul>
	 * <li>the <tt>setup</tt> method failed</li>
	 * <li>the Plugin configuration has changed</li>
	 * <li>the execution duration of the Plugin exceeded the schedule timeout</li>
	 * <li>the schedule associated with this Plugin was removed</li>
	 * </ul>
	 *
	 * <p>
	 * The Plugin methods <tt>setup</tt>, <tt>execute</tt> and
	 * <tt>teardown</tt> are called on different threads, but they are called
	 * sequentially. This means that the execution of these methods does not
	 * overlap, they are executed one after the other.
	 *
	 * <p>
	 * Examples:
	 * <ul>
	 * <li><tt>setup</tt> (failed) -&gt; <tt>teardown</tt></li>
	 * <li><tt>execute</tt> starts, configuration changes, <tt>execute</tt>
	 * ends -&gt; <tt>teardown</tt><br>
	 * on next schedule interval: <tt>setup</tt> -&gt; <tt>execute</tt> ...</li>
	 * <li><tt>execute</tt> starts, execution duration timeout,
	 * <tt>execute</tt> stops -&gt; <tt>teardown</tt></li>
	 * <li><tt>execute</tt> starts, <tt>execute</tt> ends, schedule is
	 * removed -&gt; <tt>teardown</tt></li>
	 * </ul>
	 * Failed means that either an unhandled exception is thrown or the status
	 * returned by the method contains a non-success code.
	 *
	 *
	 * <p>
	 * All by the Plugin allocated resources should be freed in this method.
	 * Examples are opened sockets or files.
	 *
	 * @see Monitor#setup(MonitorEnvironment)
	 */	@Override
	public void teardown(MonitorEnvironment env) throws Exception {
		// TODO
	}
}
